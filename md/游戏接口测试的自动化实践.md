# 游戏接口测试自动化实践

> 来testhome一周了，发了两篇理论文章，就有人嫌我水，希望我来点干货。今天发一个干货，虽然我知道你们绝大多数人都不会用到，但是我可以秀操作啊！

[toc]

## 1.背景

### 1.0 作者背景

先说一下我的背景，上海某游戏公司QA，3年游戏测试经验，虽然工作时间不长，但是接手过一个大型的页游项目和一个在研手游项目，对接口自动化方面有一定的思考和技术沉淀。

### 1.1 游戏测试行业的现状

国内的游戏测试行业目前普遍的是功能测试走天下，偶尔出来个UI自动化测试就了不得了。众所周知，UI自动化开发和维护成本高，投入性价比很低，而游戏又是一种界面千奇百怪又元素布局纷繁复杂的软件，UI自动化更是得不偿失，即使上马了自动化测试项目，往往都是虎头蛇尾。

为什么其它互联网企业，自动化测试满天飞，游戏测试行业依然如此原始。据我的观察，游戏测试应该是落后外面5年的技术沉淀。可能游戏行业已经被踢出互联网行业，划归为传统软件开发领域了吧。:laughing:

### 1.2 接口自动化测试的难点

虽然我们游戏行业落后，但是我们游戏也有接口可以测试啊！既然可以接口测试，干嘛不自动化呢？提高测试效率，多好的事儿啊。好是好，但没人做啊。

一方面，薪酬普遍比同行低几千，基本上招的都是黑盒测试，技术能力薄弱，接口测试还能搞搞，你让他们开发接口自动化平台，抱歉，没那个能力。所以游戏测试做到最后，大部分转游戏策划了，毕竟游戏是我测的，我还不了解嘛。照葫芦画瓢也能写个策划案出来。

另一方面，对于大部分的游戏而言，客户端和服务端交互，都是基于TCP协议自定义传输协议。划重点，用的不是HTTP协议！所以，相当一部分（只支持HTTP协议的）接口测试工具是没办法用的。所以游戏测试人员测接口，基本上都是各个公司开发人员编写的发包工具来测试的。开发大哥给你个测试工具就不错了，你还想怎么样？什么？要写个自动化测试工具？一边凉快去，没看到我正忙着嘛！

对于老板来说，游戏出bug有什么大不了的，给玩家补偿就好了，我要的是游戏能尽快上线赚钱，其它的一律靠边站。你让我开高工资招测试开发，那是不可能的:laughing:

其实还有其他方面的原因，比如：立项时就没有考虑到以后要做接口自动化，设计的时候也不会在给予便利；没有restful API，测一个case要有一套复杂的前置动作等，但是我觉得那都不是主要原因。

还没怎么介绍干货呢，牢骚倒是发了一堆。:sweat_smile:

### 1.3 实现自动化的意义

既然上面有一堆不利因素，你为什么还要去做接口的自动化?

那我想说：“哥是个有理想的人，虽然入错行了，但是技术牛逼啊，哥要改变这个现状！”

还有一个很重要的现实因素：因为项目组就我一个QA，我不做自动化，意味着每次更新，我都要手动去做回归测试。程序员最讨厌的事情是什么：重复！当我做了实现自动化，我可以把节省下来的时间用来写文章，多好！

## 2.做一个游戏客户端

> 理论上这个时候要讲接口自动化测试框架设计，但是现在连接口测试工具都没有，也谈不上设计自动化测试框架，先写个游戏客户端作为测试工具吧。

### 2.1游戏客户端架构设计

<img src="../images/游戏客户端.png" alt="游戏客户端" style="zoom:100%;" />

### 2.2做一个socket客户端

这个好做，随便一个编程语言，都有网络编程，你照着例子，你就能写出一个socket客户端。以python为例：

```python
import socket
HOST, PORT = "10.9.200.28", 8090
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))
message = "hello, world!".encode()
client.sendall(message)
reply = client.recv(4096)
client.close()
```

#### 2.2.3 数据封装

我们知道socket数据传递的形式是二进制数据流，一般接口数据是以json格式为主，这就涉及到了数据的封装。简单来说就是把json数据转化为字符串，然后再通过封装成二进制数据流。

对于数据封装，就涉及到了各个公司自定义的通信协议格式。我们自定义一个协议（对于客户端而言），收发的数据报文的格式如下：

![数据报文](D:\Github\quality_assurance\images\数据报文.png)

假如我要发送一个接口，数据如下：

```python
"""
服务器id：10203
接口名称：store@buy
数据包id：5
数据内容：giftId=7392&useTicket=1&ticketId=357860382
"""
import struct

serverId = 10203
command = "store@buy".encode("utf-8")
packId = 5
packData = "giftId=7392&useTicket=1&ticketId=357860382".encode("utf-8")
packLength = 40 + len(packData)
# 最终发送的数据流
data = struct.unpack(">ii32si{0}s".format(
    len(packData)), packLength, serverId, command, packId, packData)
```

接收服务端的推送就可以这样解析：

```python
"""
接口名称：store@buy
数据包id：5
状态码：200
数据内容：{msg："purchase success!"}
"""
import struct

# 假设接收到的数据流如下
cache = b'\x00\x00\x00Cstore2@buy\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05\x00\x00\x00\xc8{msg\xef\xbc\x9a"purchase success!"}'
packDataLength = len(cache) - 40
# 接收数据流
struct.unpack(">32sii{0}s".format(packDataLength), cache)
```

这里的状态码可以我使用了http的状态码，你也可以自定义一套。

#### 2.2.4 数据加密

数据加密，使用的非对称加密。简单的思路如下：

1. 客户端和服务器端建立连接
2. 客户端产生非对称密钥，将公钥传送给服务器端
3. 服务器端通过公钥将密钥进行加密并传送给客户端
4. 客户端接收到密钥并进行解密，双方开始通信



#### 2.2.5 数据压缩解压缩

### 2.3 接口层

2.3.1 接口定义

2.3.2 接口

### 2.4 接口处理层

## 3.如何实现接口自动化

### 3.1接口自动化设计

![接口自动化测试](../images/接口自动化测试.png)

### 3.2 测试用例编写

2.3.1测试用例

测试点，数据，数据验证



## 4.拓展应用

### 4.1游戏测试场景构建

例如：

### 4.2压力测试

选择单一接口或场景，多进程跑

### 4.3机器人仿真模拟

制定一定的行为策略，模拟用户的操作，收集信息，供策划决策。

策划希望研究不同计策对游戏胜负的影响，那么我只要设计场景，游戏机器人带不同计策，记录游戏结果。重复若干场，得到统计数据。策划可以分析数据，调整计策的数值。比如火攻对玩家的伤害4万。则



### 

